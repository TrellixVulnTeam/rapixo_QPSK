{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"D:/rf/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"D:/rf/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Base = void 0;\n\nvar crypto_js_1 = __importDefault(require(\"crypto-js\"));\n\nvar Base = /*#__PURE__*/function () {\n  function Base() {\n    _classCallCheck(this, Base);\n  }\n\n  _createClass(Base, [{\n    key: \"print\",\n    value:\n    /**\n     * print\n     * @desc Prints out a visual representation of the merkle tree.\n     * @example\n     *```js\n     *tree.print()\n     *```\n     */\n    function print() {\n      Base.print(this);\n    }\n    /**\n     * bufferIndexOf\n     * @desc Returns the first index of which given buffer is found in array.\n     * @param {Buffer[]} haystack - Array of buffers.\n     * @param {Buffer} needle - Buffer to find.\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.bufferIndexOf(haystack, needle)\n     *```\n     */\n\n  }, {\n    key: \"_bufferIndexOf\",\n    value: function _bufferIndexOf(array, element) {\n      for (var i = 0; i < array.length; i++) {\n        if (element.equals(array[i])) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer|ArrayBuffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = MerkleTree.bufferify('0x1234')\n     *```\n     */\n\n  }, {\n    key: \"bufferToHex\",\n    value:\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = tree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    function bufferToHex(value) {\n      var withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n\n  }, {\n    key: \"bufferify\",\n    value:\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = tree.bufferify('0x1234')\n     *```\n     */\n    function bufferify(value) {\n      return Base.bufferify(value);\n    }\n    /**\n     * bufferifyFn\n     * @desc Returns a function that will bufferify the return value.\n     * @param {Function}\n     * @return {Function}\n     *\n     * @example\n     * ```js\n     *const fn = tree.bufferifyFn((value) => sha256(value))\n     *```\n     */\n\n  }, {\n    key: \"bufferifyFn\",\n    value: function bufferifyFn(f) {\n      var _this = this;\n\n      return function (value) {\n        var v = f(value);\n\n        if (Buffer.isBuffer(v)) {\n          return v;\n        }\n\n        if (_this._isHexString(v)) {\n          return Buffer.from(v.replace('0x', ''), 'hex');\n        }\n\n        if (typeof v === 'string') {\n          return Buffer.from(v);\n        }\n\n        if (ArrayBuffer.isView(v)) {\n          return Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n        } // crypto-js support\n\n\n        return Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n      };\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n\n  }, {\n    key: \"_isHexString\",\n    value: function _isHexString(value) {\n      return Base.isHexString(value);\n    }\n    /**\n     * log2\n     * @desc Returns the log2 of number.\n     * @param {Number} value\n     * @return {Number}\n     */\n\n  }, {\n    key: \"_log2\",\n    value: function _log2(n) {\n      return n === 1 ? 0 : 1 + this._log2(n / 2 | 0);\n    }\n    /**\n     * zip\n     * @desc Returns true if value is a hex string.\n     * @param {String[]|Number[]|Buffer[]} a - first array\n     * @param {String[]|Number[]|Buffer[]} b -  second array\n     * @return {String[][]|Number[][]|Buffer[][]}\n     *\n     * @example\n     * ```js\n     *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n     *```\n     */\n\n  }, {\n    key: \"_zip\",\n    value: function _zip(a, b) {\n      return a.map(function (e, i) {\n        return [e, b[i]];\n      });\n    }\n  }], [{\n    key: \"bufferify\",\n    value: function bufferify(value) {\n      if (!Buffer.isBuffer(value)) {\n        // crypto-js support\n        if (typeof value === 'object' && value.words) {\n          return Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n        } else if (Base.isHexString(value)) {\n          return Buffer.from(value.replace(/^0x/, ''), 'hex');\n        } else if (typeof value === 'string') {\n          return Buffer.from(value);\n        } else if (typeof value === 'number') {\n          var s = value.toString();\n\n          if (s.length % 2) {\n            s = \"0\".concat(s);\n          }\n\n          return Buffer.from(s, 'hex');\n        } else if (ArrayBuffer.isView(value)) {\n          return Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n        }\n      }\n\n      return value;\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n\n  }, {\n    key: \"isHexString\",\n    value: function isHexString(v) {\n      return typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v);\n    }\n    /**\n     * print\n     * @desc Prints out a visual representation of the given merkle tree.\n     * @param {Object} tree - Merkle tree instance.\n     * @return {String}\n     * @example\n     *```js\n     *MerkleTree.print(tree)\n     *```\n     */\n\n  }, {\n    key: \"print\",\n    value: function print(tree) {\n      console.log(tree.toString());\n    }\n  }, {\n    key: \"bufferToHex\",\n    value: function bufferToHex(value) {\n      var withPrefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return \"\".concat(withPrefix ? '0x' : '').concat((value || Buffer.alloc(0)).toString('hex'));\n    }\n  }]);\n\n  return Base;\n}();\n\nexports.Base = Base;\nexports.default = Base;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Base","crypto_js_1","require","print","array","element","i","length","equals","withPrefix","bufferToHex","bufferify","f","v","Buffer","isBuffer","_isHexString","from","replace","ArrayBuffer","isView","buffer","byteOffset","byteLength","default","enc","Hex","parse","toString","isHexString","n","_log2","a","b","map","e","words","s","test","tree","console","log","alloc"],"sources":["D:/rf/node_modules/merkletreejs/dist/Base.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Base = void 0;\nconst crypto_js_1 = __importDefault(require(\"crypto-js\"));\nclass Base {\n    /**\n     * print\n     * @desc Prints out a visual representation of the merkle tree.\n     * @example\n     *```js\n     *tree.print()\n     *```\n     */\n    print() {\n        Base.print(this);\n    }\n    /**\n     * bufferIndexOf\n     * @desc Returns the first index of which given buffer is found in array.\n     * @param {Buffer[]} haystack - Array of buffers.\n     * @param {Buffer} needle - Buffer to find.\n     * @return {Number} - Index number\n     *\n     * @example\n     * ```js\n     *const index = tree.bufferIndexOf(haystack, needle)\n     *```\n     */\n    _bufferIndexOf(array, element) {\n        for (let i = 0; i < array.length; i++) {\n            if (element.equals(array[i])) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer|ArrayBuffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = MerkleTree.bufferify('0x1234')\n     *```\n     */\n    static bufferify(value) {\n        if (!Buffer.isBuffer(value)) {\n            // crypto-js support\n            if (typeof value === 'object' && value.words) {\n                return Buffer.from(value.toString(crypto_js_1.default.enc.Hex), 'hex');\n            }\n            else if (Base.isHexString(value)) {\n                return Buffer.from(value.replace(/^0x/, ''), 'hex');\n            }\n            else if (typeof value === 'string') {\n                return Buffer.from(value);\n            }\n            else if (typeof value === 'number') {\n                let s = value.toString();\n                if (s.length % 2) {\n                    s = `0${s}`;\n                }\n                return Buffer.from(s, 'hex');\n            }\n            else if (ArrayBuffer.isView(value)) {\n                return Buffer.from(value.buffer, value.byteOffset, value.byteLength);\n            }\n        }\n        return value;\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    static isHexString(v) {\n        return (typeof v === 'string' && /^(0x)?[0-9A-Fa-f]*$/.test(v));\n    }\n    /**\n     * print\n     * @desc Prints out a visual representation of the given merkle tree.\n     * @param {Object} tree - Merkle tree instance.\n     * @return {String}\n     * @example\n     *```js\n     *MerkleTree.print(tree)\n     *```\n     */\n    static print(tree) {\n        console.log(tree.toString());\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = tree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    bufferToHex(value, withPrefix = true) {\n        return Base.bufferToHex(value, withPrefix);\n    }\n    /**\n     * bufferToHex\n     * @desc Returns a hex string with 0x prefix for given buffer.\n     * @param {Buffer} value\n     * @return {String}\n     * @example\n     *```js\n     *const hexStr = MerkleTree.bufferToHex(Buffer.from('A'))\n     *```\n     */\n    static bufferToHex(value, withPrefix = true) {\n        return `${withPrefix ? '0x' : ''}${(value || Buffer.alloc(0)).toString('hex')}`;\n    }\n    /**\n     * bufferify\n     * @desc Returns a buffer type for the given value.\n     * @param {String|Number|Object|Buffer} value\n     * @return {Buffer}\n     *\n     * @example\n     * ```js\n     *const buf = tree.bufferify('0x1234')\n     *```\n     */\n    bufferify(value) {\n        return Base.bufferify(value);\n    }\n    /**\n     * bufferifyFn\n     * @desc Returns a function that will bufferify the return value.\n     * @param {Function}\n     * @return {Function}\n     *\n     * @example\n     * ```js\n     *const fn = tree.bufferifyFn((value) => sha256(value))\n     *```\n     */\n    bufferifyFn(f) {\n        return (value) => {\n            const v = f(value);\n            if (Buffer.isBuffer(v)) {\n                return v;\n            }\n            if (this._isHexString(v)) {\n                return Buffer.from(v.replace('0x', ''), 'hex');\n            }\n            if (typeof v === 'string') {\n                return Buffer.from(v);\n            }\n            if (ArrayBuffer.isView(v)) {\n                return Buffer.from(v.buffer, v.byteOffset, v.byteLength);\n            }\n            // crypto-js support\n            return Buffer.from(f(crypto_js_1.default.enc.Hex.parse(value.toString('hex'))).toString(crypto_js_1.default.enc.Hex), 'hex');\n        };\n    }\n    /**\n     * isHexString\n     * @desc Returns true if value is a hex string.\n     * @param {String} value\n     * @return {Boolean}\n     *\n     * @example\n     * ```js\n     *console.log(MerkleTree.isHexString('0x1234'))\n     *```\n     */\n    _isHexString(value) {\n        return Base.isHexString(value);\n    }\n    /**\n     * log2\n     * @desc Returns the log2 of number.\n     * @param {Number} value\n     * @return {Number}\n     */\n    _log2(n) {\n        return n === 1 ? 0 : 1 + this._log2((n / 2) | 0);\n    }\n    /**\n     * zip\n     * @desc Returns true if value is a hex string.\n     * @param {String[]|Number[]|Buffer[]} a - first array\n     * @param {String[]|Number[]|Buffer[]} b -  second array\n     * @return {String[][]|Number[][]|Buffer[][]}\n     *\n     * @example\n     * ```js\n     *const zipped = tree.zip(['a', 'b'],['A', 'B'])\n     *console.log(zipped) // [ [ 'a', 'A' ], [ 'b', 'B' ] ]\n     *```\n     */\n    _zip(a, b) {\n        return a.map((e, i) => [e, b[i]]);\n    }\n}\nexports.Base = Base;\nexports.default = Base;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}